ES6

1. ES5、ES6（ES2015）有什么区别?

	let 和 const 关键字：ES5 中只有 var 关键字用于声明变量，而 ES6 引入了 let 和 const。let 具有块级作用域，而 const 用于声明常量。
	箭头函数：ES6 引入了箭头函数，它简化了函数的定义，并且没有自己的 this，它会捕获所在上下文的 this 值。
	类和继承：ES6 引入了类和 extends 关键字，提供了更清晰的面向对象编程语法。
	模块化：ES6 引入了模块化概念，通过 export 和 import 可以更方便地组织和管理代码。
	解构赋值：ES6 允许通过解构赋值语法从数组或对象中提取值并赋给变量。

2. 解释babel是什么，有什么作用?

	将新版本 JavaScript 转换为旧版本： Babel 允许开发者使用最新的 JavaScript 语法和功能（比如 ES6+）编写代码，并将其转换成可在不同环境中运行的代码，如 ES5。这样，开发者可以利用最新的语言特性而不用担心兼容性问题。
	提供插件机制： Babel 可以通过插件进行扩展，允许开发者根据自己的需求自定义转换过程。这些插件用于处理特定的语法转换或功能转换，从而使 Babel 更灵活、更可定制。

3. 简述ES6 let有什么用，有了var为什么还要用let？

	块级作用域： 使用 let 声明的变量具有块级作用域，而 var 声明的变量具有函数级作用域。这意味着，使用 let 声明的变量在声明的块内部有效，而 var 整个函数内部都是有效的。
	暂时性死区（Temporal Dead Zone，TDZ）： 在块级作用域内使用 let 声明的变量在声明之前是不可访问的，这被称为暂时性死区。这有助于捕获在使用变量之	前就引用了它的错误。

4. 简述ES6对String字符串类型做的常用升级优化?
	模板字符串（Template Strings）： 使用反引号（``）创建模板字符串，可以在字符串中嵌入变量和表达式，使得字符串拼接更加清晰和简洁。
	多行字符串： 在模板字符串中可以轻松创建多行字符串，而不需要使用 \n 进行换行。
	字符串新增方法： ES6 添加了许多新的字符串方法，使得字符串的处理更加便利。例如，startsWith()、endsWith()、includes() 等方法用于检查字符串头，结尾和包含关系

5. 简述ES6对Array数组类型做的常用升级优化?
	
	扩展运算符（Spread Operator）： 允许在数组字面量、函数调用、以及其他表达式中展开数组，使得数组操作更加灵活。
	Array.from() 方法： 可以将类数组对象或可迭代对象转换为真正的数组。
	find() 和 findIndex() 方法： find() 可以根据条件查找数组中符合条件的第一个元素，而 findIndex() 则返回符合条件的第一个元素的索引。

6. 简述ES6对Number数字类型做的常用升级优化?
	
	二进制和八进制表示法： ES6 引入了二进制（0b或0B前缀）和八进制（0o或0O前缀）的表示法，使得数值的书写更加灵活。
	Number.isFinite() 和 Number.isNaN() 方法： 新增的这两个方法用于更准确地检测数字是否有限和是否为 NaN。
	Number.isInteger() 方法： 用于判断一个数值是否为整数。
	Number.isSafeInteger() 方法： 判断一个整数是否在可安全范围内，避免溢出。
	Number.EPSILON： 新增常量，表示浮点数的计算精度，通常用于比较浮点数是否相等。
	安全整数范围： 引入了 Number.MIN_SAFE_INTEGER 和 Number.MAX_SAFE_INTEGER 常量，表示在 JavaScript 中能够安全表示的最小和最大整数。

7. 简述ES6对Object类型做的常用升级优化? ( 重要 )

	对象属性的简写： ES6 允许在对象字面量中，如果属性名和变量名相同，可以只写属性名，不写冒号和值。
	对象方法的简写： 在对象字面量中，可以使用简写方式定义方法。
	计算属性名： ES6 允许在对象字面量中使用计算表达式作为属性名。

8. 简述ES6对Function函数类型做的常用升级优化 ? ( 重要 )

	箭头函数： 箭头函数是 ES6 中引入的一种新的函数定义方式，它具有更简洁的语法和改变了 this 的行为。
	默认参数值： ES6 允许在函数参数中设置默认值。
	Rest 参数： 允许函数接收不定数量的参数，并将其放入一个数组中。

9. 简述ES6 Symbol的作用？
	
	独一无二性：Symbol的值是独一无二的，可以用作对象属性名，确保属性名的唯一性。
	隐藏性：由于Symbol的值是唯一的且不可改变的，所以使用Symbol作为属性名可以隐藏一些不需要对外暴露的属性。
	解决命名冲突：在多人协作或者使用第三方库的情况下，使用Symbol可以避免命名冲突问题。
	作为常量：可以使用Symbol来定义常量，因为每个Symbol的值都是唯一的。
	
10.  简述ES6 Set的作用？
	
	去重：Set中的成员都是唯一的，当需要对一个数组进行去重操作时，可以使用Set来实现。判断两个值是否相同是通过"Same-value-zero equality"算法来判断】的，这与JavaScript中的"==="不同。
	数组与Set的相互转换：可以通过Array.from方法将Set转换为数组，也可以通过扩展运算符(...)将数组转换为Set。

11. 简述ES6 Map的作用？

	存储任意类型的键和值：Map可以使用各种数据类型作为键，包括字符串、数字、布尔值、对象等，而且键与值之间是一对一的关系。
	保持插入顺序：与对象不同，Map会按照元素的插入顺序进行迭代。这使得我们能够按照特定顺序遍历Map中的键值对。
	提供更灵活的键查找机制：Map提供了多种方法来查找键，包括get()方法、has()方法和delete()方法。通过这些方法，我们可以很方便地判断某个键是否存在，获取对应的值，以及删除指定的键值对。

12. 简述ES6 Proxy的作用？

	拦截和自定义对象属性的访问：通过使用Proxy，可以对对象的属性进行拦截、修改、添加或删除等操作。这使得我们能够监控和控制对象属性的读取和写入行为。
	拦截和自定义函数调用：Proxy还可以拦截函数的调用，即对函数进行预处理或后处理。这样可以实现参数验证、性能统计、缓存等功能。

13. 简述ES6 Reflect的作用？

	统一对象操作的API：Reflect对象提供了一系列与对象操作相关的静态方法，如Reflect.get、Reflect.set等，这些方法与原本的Object方法功能类似，但是具有一致性，使用起来更加方便。
	更好的封装行为：通过Reflect对象可以对对象的操作进行拦截和修改。例如，可以使用Reflect.get方法来获取对象的属性值，在获取属性值之前可以进行一些额外的操作，从而实现更好的封装行为。

14. 简述ES6 Promise 的作用？

	ES6 Promise 是用于处理异步操作的一种机制，它的作用在于更加优雅地解决回调地狱（callback hell）问题，使得异步操作的处理更加清晰和便利。
	具体来说，ES6 Promise 提供了一种更加灵活的方式来处理异步操作，通过使用 Promise 对象，可以更加直观地表达异步操作的状态和结果。Promise 对象可以处于三种状态：进行中、已成功和已失败，这	有助于更好地管理和处理异步操作的结果。

15. 简述ES6 Iterator的作用？( 重要 )

	ES6 Iterator 提供了一个统一的遍历接口，通过定义next()方法，可以让不同的数据结构（如数组、对象、Map、Set 等）都能够被迭代遍历。这种统一的遍历接口使得我们可以使用相似的语法来遍历不同的	数据结构，极大地提高了代码的通用性和可复用性。