js面试题

1， 简述JavaScript中map和foreach的区别？
	map: 返回一个新的数组，该数组的元素是原始数组中的每个元素调用函数后的结果。
	forEach: 没有返回值，它仅用于迭代数组，执行提供的回调函数，但不创建新的数组。
	map: 函数应用于每个元素时，不会修改原始数组，而是创建一个新的数组。
	forEach: 可以在回调函数中修改原始数组的元素，因为它没有返回新的数组。

2. 解释下JavaScript中this是如何工作的？
	全局上下文中的 this：在全局作用域中，this 指向全局对象，在浏览器中是 window 对象，在 Node.js 中是 global 对象。
	作为方法调用时： 当函数作为对象的方法被调用时，this 指向调用该方法的对象。
	作为普通函数调用时： 如果函数独立调用，this 通常指向全局对象（在严格模式下是 undefined）。
	使用 call、apply 或 bind 方法时： 这些方法允许显式地设置函数内部的 this 值。
	箭头函数中的 this： 箭头函数没有自己的 this，它继承自外围最近一层非箭头函数的上下文。

3. 简述异步线程，轮询机制，宏任务微任务？
	异步线程（Asynchronous Thread）
	JavaScript 是一种单线程语言，意味着它一次只能执行一个任务。然而，它支持异步编程模型，
	允许某些操作在后台运行而不阻塞主线程的执行。浏览器环境中，异步工作	通常是由 Web API、事件处理程序以及 Promise 等机制实现的。
	轮询机制（Event Loop）
	JavaScript 中的事件循环（Event Loop）是一种机制，负责管理执行堆栈中的代码和处理异步任务。它在等待任务完成时持续运行，确保及时处理事件和执行任	务。事件循环主要由两个
	宏任务（Macro Tasks）： 代表需要被放入执行队列的任务，每个宏任务完成后，事件循环会检查微任务队列。典型的宏任务包括整体的 	script、setTimeout、setInterval、I/O 操作	等。它们会被依次添加到宏任务队列中等待执行。
	微任务（Micro Tasks）： 微任务是在当前任务（宏任务）执行结束后立即执行的任务。微任务包括 Promise 的 then 方法和 catch 方	法、MutationObserver 等。微任务队列在每个	宏任务执行结束后会被立即处理。

4. JavaScript阻止事件冒泡的方法？
	可以使用 stopPropagation 方法来阻止事件冒泡。事件冒泡是指事件从触发它的最深的嵌套元素开始向上传播到根元素的过程。通过阻止事件冒泡。

5. JavaScript阻止默认事件？
	可以使用 preventDefault 方法来阻止事件的默认行为。默认行为是指浏览器在特定事件上执行的预定义操作，例如点击链接时的页面导航、提交表单时的页面刷	新等。通过阻止默认行为

6. Javascript 怎样判断array 和 object ?
	可以使用 Array.isArray() 方法来判断一个值是否为数组，而使用 typeof 操作符来判断一个值是否为对象。
	使用 Array.isArray() 方法来检查一个值是否为数组。这个方法在数组类型上返回 true，否则返回 false。
	使用 typeof 操作符可以检查一个值的类型。然而，需要注意的是，typeof 对于数组也会返回 'object'，因此不能仅仅依赖 typeof 来判断是否为对象。

7. 简述 Javascript 盒子模型?
	盒子模型是指每个 HTML 元素在页面中所占据的空间，它由四个部分组成：
	内容区域（Content）： 元素实际包含的内容，例如文本、图片等。
	内边距（Padding）： 内容区域与边框之间的空间。可以通过 CSS 的 padding 属性控制。
	边框（Border）： 内容和内边距之外的边框线。可以通过 CSS 的 border 属性控制。
	外边距（Margin）： 元素与相邻元素之间的空间。可以通过 CSS 的 margin 属性控制。

8. Javascript 对象的key能是数字吗？
	JavaScript 中，对象的键（key）可以是字符串或符号（symbol），但不能是数字。当你使用数字作为对象的键时，JavaScript 解释器会将其隐式转换为字符	串。

9. Javascipt中async await 和promise和generator有什么区别
	1. Promise:
	基础概念： Promise 是一种表示异步操作的对象，它有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。一个 Promise 对象代	表一个异步操作的最终完成	或失败，并返回相应的结果值。
	2. Async/Await:
	基础概念： async 和 await 是 ES2017（ES8）引入的语法糖，用于更方便地处理 Promise。async 函数返回一个 Promise 对象，而在 async 函数内部，	await 表达式用于等待一个 	Promise 对象的解决。
	3. Generator:
	基础概念： Generator 是一种可以暂停和继续执行的函数，通过 yield 关键字可以将执行权交出。Generator 不同于 Promise 和 async/await，它是一种更	底层的异步控制工具。
	使用方式： 通过调用 Generator 函数生成一个 Iterator，并通过 next 方法控制 Generator 函数的执行。
	使用方式： 使用 async 关键字定义一个异步函数，其中可以使用 await 来等待其他异步操作的完成。
	使用方式： 使用 then 方法处理异步操作的结果，以及 catch 方法处理错误。

10. JavaScript中手写promise ？
	写一个 Promise 时，你需要实现 Promise 的基本结构，包括三个状态（pending、fulfilled、rejected）以及与这些状态相关的操（resolve、reject）。

11，ajax原理是什么？

	AJAX 全称(Async Javascript and XML)
	即异步的 JavaScript 和 XML，是一种创建交互式网页应用的网页开发技术，可以在不重新加载整个网页的情况下，与服务器交换数据，并且更新部分网页
	Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面

12，Javascript如何实现继承？

	继承（inheritance）是面向对象软件技术当中的一个概念。
	如果一个类别B“继承自”另一个类别A，就把这个B称为“A的子类”，而把A称为“B的父类别”也可以称“A是B的超类”
	继承的优点：
	继承可以使得子类具有父类别的各种属性和方法，而不需要再次编写相同的代码
	在子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能

13，谈谈this对象的理解

	函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别
	在绝大多数情况下，函数的调用方式决定了 this 的值（运行时绑定）
	this 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象

14，typeof 与 instanceof 区别

	typeof 操作符返回一个字符串，表示未经计算的操作数的类型
	instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上

15，说说new操作符具体干了什么？

	在JavaScript中，new操作符用于创建一个给定构造函数的实例对象
	new 通过构造函数 Person 创建出来的实例可以访问到构造函数中的属性
	new 通过构造函数 Person 创建出来的实例可以访问到构造函数原型链中的属性（即实例与构造函数通过原型链连接了起来）

16，说说你对正则表达式的理解？

	正则表达式是一种用来匹配字符串的强有力的武器
	它的设计思想是用一种描述性的语言定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的
	使用构建函数创建，第一个参数可以是一个变量，遇到特殊字符\需要使用\\进行转义

17，DOM常见的操作有哪些

	它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容
	任何 HTML 或XML文档都可以用 DOM 表示为一个由节点构成的层级结构
	DOM常见的操作，主要分为：创建节点 查询节点 更新节点 添加节点 删除节点

18，什么是防抖和节流？

	resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能
	定义
	节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效
	防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时

19，解释下什么是事件代理？

	事件代理，俗地来讲，就是把一个元素响应事件（click、keydown......）的函数委托到另一个元素
	前面讲到，事件流的都会经过三个阶段： 捕获阶段 -> 目标阶段 -> 冒泡阶段，而事件委托就是在冒泡阶段完成
	事件委托，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，而不是目标元素
	当事件响应到目标元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数

20，JavaScript中的事件模型

	javascript中的事件，可以理解就是在HTML文档或者浏览器中发生的一种交互操作，使得网页具备互动性， 常见的有加载事件、鼠标事件、自定义事件等
	由于DOM是一个树结构，如果在父子节点绑定事件时候，当触发子节点的时候，就存在一个顺序问题，这就涉及到了事件流的概念
	事件流都会经历三个阶段：
	事件捕获阶段(capture phase)
	处于目标阶段(target phase)
	事件冒泡阶段(bubbling phase)

ES6

1. ES5、ES6（ES2015）有什么区别?

	let 和 const 关键字：ES5 中只有 var 关键字用于声明变量，而 ES6 引入了 let 和 const。let 具有块级作用域，而 const 用于声明常量。
	箭头函数：ES6 引入了箭头函数，它简化了函数的定义，并且没有自己的 this，它会捕获所在上下文的 this 值。
	类和继承：ES6 引入了类和 extends 关键字，提供了更清晰的面向对象编程语法。
	模块化：ES6 引入了模块化概念，通过 export 和 import 可以更方便地组织和管理代码。
	解构赋值：ES6 允许通过解构赋值语法从数组或对象中提取值并赋给变量。

2. 解释babel是什么，有什么作用?

	将新版本 JavaScript 转换为旧版本： Babel 允许开发者使用最新的 JavaScript 语法和功能（比如 ES6+）编写代码，并将其转换成可在不同环境中运行的代码，如 ES5。这样，开发者可以利用最新的语言特性而不用担心兼容性问题。
	提供插件机制： Babel 可以通过插件进行扩展，允许开发者根据自己的需求自定义转换过程。这些插件用于处理特定的语法转换或功能转换，从而使 Babel 更灵活、更可定制。

3. 简述ES6 let有什么用，有了var为什么还要用let？

	块级作用域： 使用 let 声明的变量具有块级作用域，而 var 声明的变量具有函数级作用域。这意味着，使用 let 声明的变量在声明的块内部有效，而 var 整个函数内部都是有效的。
	暂时性死区（Temporal Dead Zone，TDZ）： 在块级作用域内使用 let 声明的变量在声明之前是不可访问的，这被称为暂时性死区。这有助于捕获在使用变量之	前就引用了它的错误。

4. 简述ES6对String字符串类型做的常用升级优化?
	模板字符串（Template Strings）： 使用反引号（``）创建模板字符串，可以在字符串中嵌入变量和表达式，使得字符串拼接更加清晰和简洁。
	多行字符串： 在模板字符串中可以轻松创建多行字符串，而不需要使用 \n 进行换行。
	字符串新增方法： ES6 添加了许多新的字符串方法，使得字符串的处理更加便利。例如，startsWith()、endsWith()、includes() 等方法用于检查字符串头，结尾和包含关系

5. 简述ES6对Array数组类型做的常用升级优化?
	
	扩展运算符（Spread Operator）： 允许在数组字面量、函数调用、以及其他表达式中展开数组，使得数组操作更加灵活。
	Array.from() 方法： 可以将类数组对象或可迭代对象转换为真正的数组。
	find() 和 findIndex() 方法： find() 可以根据条件查找数组中符合条件的第一个元素，而 findIndex() 则返回符合条件的第一个元素的索引。

6. 简述ES6对Number数字类型做的常用升级优化?
	
	二进制和八进制表示法： ES6 引入了二进制（0b或0B前缀）和八进制（0o或0O前缀）的表示法，使得数值的书写更加灵活。
	Number.isFinite() 和 Number.isNaN() 方法： 新增的这两个方法用于更准确地检测数字是否有限和是否为 NaN。
	Number.isInteger() 方法： 用于判断一个数值是否为整数。
	Number.isSafeInteger() 方法： 判断一个整数是否在可安全范围内，避免溢出。
	Number.EPSILON： 新增常量，表示浮点数的计算精度，通常用于比较浮点数是否相等。
	安全整数范围： 引入了 Number.MIN_SAFE_INTEGER 和 Number.MAX_SAFE_INTEGER 常量，表示在 JavaScript 中能够安全表示的最小和最大整数。

7. 简述ES6对Object类型做的常用升级优化? ( 重要 )

	对象属性的简写： ES6 允许在对象字面量中，如果属性名和变量名相同，可以只写属性名，不写冒号和值。
	对象方法的简写： 在对象字面量中，可以使用简写方式定义方法。
	计算属性名： ES6 允许在对象字面量中使用计算表达式作为属性名。

8. 简述ES6对Function函数类型做的常用升级优化 ? ( 重要 )

	箭头函数： 箭头函数是 ES6 中引入的一种新的函数定义方式，它具有更简洁的语法和改变了 this 的行为。
	默认参数值： ES6 允许在函数参数中设置默认值。
	Rest 参数： 允许函数接收不定数量的参数，并将其放入一个数组中。

9. 简述ES6 Symbol的作用？
	
	独一无二性：Symbol的值是独一无二的，可以用作对象属性名，确保属性名的唯一性。
	隐藏性：由于Symbol的值是唯一的且不可改变的，所以使用Symbol作为属性名可以隐藏一些不需要对外暴露的属性。
	解决命名冲突：在多人协作或者使用第三方库的情况下，使用Symbol可以避免命名冲突问题。
	作为常量：可以使用Symbol来定义常量，因为每个Symbol的值都是唯一的。
	
10.  简述ES6 Set的作用？
	
	去重：Set中的成员都是唯一的，当需要对一个数组进行去重操作时，可以使用Set来实现。判断两个值是否相同是通过"Same-value-zero equality"算法来判断】的，这与JavaScript中的"==="不同。
	数组与Set的相互转换：可以通过Array.from方法将Set转换为数组，也可以通过扩展运算符(...)将数组转换为Set。

11. 简述ES6 Map的作用？

	存储任意类型的键和值：Map可以使用各种数据类型作为键，包括字符串、数字、布尔值、对象等，而且键与值之间是一对一的关系。
	保持插入顺序：与对象不同，Map会按照元素的插入顺序进行迭代。这使得我们能够按照特定顺序遍历Map中的键值对。
	提供更灵活的键查找机制：Map提供了多种方法来查找键，包括get()方法、has()方法和delete()方法。通过这些方法，我们可以很方便地判断某个键是否存在，获取对应的值，以及删除指定的键值对。

12. 简述ES6 Proxy的作用？

	拦截和自定义对象属性的访问：通过使用Proxy，可以对对象的属性进行拦截、修改、添加或删除等操作。这使得我们能够监控和控制对象属性的读取和写入行为。
	拦截和自定义函数调用：Proxy还可以拦截函数的调用，即对函数进行预处理或后处理。这样可以实现参数验证、性能统计、缓存等功能。

13. 简述ES6 Reflect的作用？

	统一对象操作的API：Reflect对象提供了一系列与对象操作相关的静态方法，如Reflect.get、Reflect.set等，这些方法与原本的Object方法功能类似，但是具有一致性，使用起来更加方便。
	更好的封装行为：通过Reflect对象可以对对象的操作进行拦截和修改。例如，可以使用Reflect.get方法来获取对象的属性值，在获取属性值之前可以进行一些额外的操作，从而实现更好的封装行为。

14. 简述ES6 Promise 的作用？

	ES6 Promise 是用于处理异步操作的一种机制，它的作用在于更加优雅地解决回调地狱（callback hell）问题，使得异步操作的处理更加清晰和便利。
	具体来说，ES6 Promise 提供了一种更加灵活的方式来处理异步操作，通过使用 Promise 对象，可以更加直观地表达异步操作的状态和结果。Promise 对象可以处于三种状态：进行中、已成功和已失败，这	有助于更好地管理和处理异步操作的结果。

15. 简述ES6 Iterator的作用？( 重要 )

	ES6 Iterator 提供了一个统一的遍历接口，通过定义next()方法，可以让不同的数据结构（如数组、对象、Map、Set 等）都能够被迭代遍历。这种统一的遍历接口使得我们可以使用相似的语法来遍历不同的	数据结构，极大地提高了代码的通用性和可复用性。

	
